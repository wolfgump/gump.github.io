## 拜占庭将军问题 The Byzantine Generals Problem

**解决的是共识问题**，不是一致性问题；计划达成了共识，然后执行计划，实现了一致行动。

在具体拜占庭问题中，只要达成进攻或者撤退的共识就行，不去考虑是否一起执行错了的指令，只要一起执行就行；

所以说拜占庭将军问题解法限制在特定场景

### 口信消息型拜占庭问题之解

限定：

A1.每个发送的消息都会被正确的传输；
A2.消息的接收者知道谁发送了消息；
A3.消息的缺席可以检测出来.

公式：

n 位将军，最多能容忍 (n - 1) / 3 位叛将，要进行（n-1）/3+1次询问

### 签名消息型拜占庭问题之解

限定：

在上面A1、A2、A3基础上增加以下两条限定

A4.忠诚的将军的签名不可以被伪造，他的签名信息的内容的任何改动都可以被检测;
A5.任何人可以验证签名的真实性.

## CAP理论

- C Consistency 一致性
- A Avaiablity 可用性
- P Partiion tolerance 分区容错性

- CA 模型，在分布式系统中不存在。因为舍弃 P，意味着舍弃分布式系统，就比如单机版关系型数据库 MySQL，如果 MySQL 要考虑主备或集群部署时，它必须考虑 P。
- CP 模型，采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，**集群将拒绝新数据的写入**，典型的应用是 ZooKeeper，Etcd 和 HBase。
- AP 模型，采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同的节点，**得到响应数据可能不一样**。典型应用就比如 Cassandra 和 DynamoDB、Eurake。

## ACID 理论

- A Atomicity
- C Consistency
- I Isolation
- D Durability

### 单机ACID

以Mysql为例：

- A 原子性   通过UndoLog实现要么全部成功 要么全部失败
- D  持久性  通过RedoLog实现数据持久化一定成功
- I  隔离性   通过锁和MVVC
- C  一致性  通过AID保证一致性

### 分布式ACID

- 2PC

  第一个阶段锁定资源、第二阶段提交事务；降低并发

- TCC 

  业务层自己实现，复杂度高

## Base理论

base理论是CAP理论中AP的衍生，有以下两点核心

- 保证服务的基本可用

  具体措施有以下几点：

  - 流量削峰 如火车票  深圳8点开卖 北京9点开卖
  - 延迟响应 排队
  - 服务降级 保证核心功能可用
  - 过载保护  限流
  - 服务熔断  防止服务级联崩溃

- 保证服务的最终一致性

  有以下措施：

  - 读时修复，在读数据时通过多节点数据比对，发现数据不一致时进行修复；数据比对比较耗性能，这种方案比较少用
  - 写时修复，在写入数据，检测数据的不一致时，进行修复。如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性，或者通过消息中间件。
  - 异步修复，这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。


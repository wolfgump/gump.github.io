---
layout: post
title: "数据结构和算法之美"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 学习笔记 
    - 算法
    - 笔记
---

# 数据结构和算法之美学习笔记



 ## 总览



<img src="/img/sturct/xmind.jpeg" alt="xmind" style="zoom:25%;" />

## 复杂度分析

<img src="/img/sturct/fuzadu.jpeg" alt="fuzadu" style="zoom:25%;" />

- 只关注循环次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### O(logn)

分析如下两段代码：

```java
i=1;
while(i<=n){
  i=i*2
}
```

```java
i=n;
while(i>=1){
  i=i/2;
}
```

代码运行的次数为：

2^0,2^1,2^2......2^x=n; x=logn

### 最好、最坏、平均、均摊时间复杂度

- 平均 加权平均

- 均摊

  > 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 数组

> 定义：数组Array是一种线性数据结构，它用一组连续的内存空间，来存储一组具有相同数据类型的数据

### ArrayList 
 最大的好处是可以将很多数组操作的细节封装起来，支持动态扩容，最好事先指定大小

对比ArrayList,什么时候使用数组呢，存储基本类型int long等时，使用ArrayList存在装箱 拆箱

链表练习操作：

- 链表翻转  指针思想
- 链表合并  哨兵节点
- 链表环检测  快慢指针
- 删除倒数第K个节点  快慢指针
- 查找中间节点   快慢指针 快两倍

## 栈

用数组实现的顺序栈

用链表实现的链式栈

栈的应用：

- 函数调用

- 表达式求值

  > 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较

- 括号匹配

## 队列

用数组实现顺序队列

用链表实现链式队列

- 循环队列  解决数据搬移
- 阻塞队列  生产者消费者模型
- 并发队列  线程安全的队列

## 递归
递归需要满足条件：

- 一个问题的解可以分解为几个子问题的解
- 这个问题和分解后的子问题，除了数据规模不同，求解思路完全相同
- 存在终止条件

写出递归代码的关键：写出递归公式，找到终止条件

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

> 例子：n个台阶，每次可以走一个台阶或者两个台阶，一共有多少走法？
>
> 可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：f(n)=f(n-1)+f(n-2);其中f(1)=1;f(2)=2
>
> 抽象成代码就是：
>
> ```java
> int f(int n) { 
>   if (n == 1)
>     return 1;
>   if (n == 2) 
>     return 2;
>   return f(n-1) + f(n-2);
> }
> ```
>
> 

### 警惕栈溢出

调用层次过深，栈溢出；解决办法是限制调用层次

### 警惕重复计算

f(n)=f(n-1)+f(n-3);

f(3)=f(2)+f(1);

f(4)=f(3)+f(2);

f(2)存在重复计算，可以通过一个map保存计算结果

## 排序
### 排序的关键指标
- 最好情况、最坏情况、平均情况时间复杂度
- 时间复杂度的系数、常数 、低阶
- 比较次数和交换（或移动）次数
- 排序算法的内存消耗
- 排序算法的稳定性，不稳定是存在着无序交换，选择排序和快速排序

### 时间复杂度总览

<img src="/img/sturct/paixu0.jpg" alt="paixu0" style="zoom:50%;" />

## 插入排序 冒泡排序 选择排序

![paixu1](/img/sturct/paixu1.jpg)



插入排序总体最优，选择排序不是稳定排序算法，使用的最少

这三种适用于小规模数据排序

## 归并排序  快速排序

核心思想：分治

- 时间复杂度  
  - 归并排序  最好 最坏 平均都是O(NLog^N)
  - 快速排序 平均是O(NLog^N)  最坏O(n^2)
- 空间复杂度
  - 归并排序不是原地排序算法，子数组合并时需要借助额外的数组空间
  - 快速排序是原地排序算法，所以快速排序应用更广
- 稳定性
  - 归并排序稳定
  - 快排不稳定

对比图

<img src="/img/sturct/paixu3.jpg" alt="paixu3" style="zoom:50%;" />



## 线性排序- 桶排序、计数排序、基数排序

时间复杂度：

- 桶排序O(n)
- 计数排序 O(n)
- 基数排序O(n)

稳定：

- 桶排序 稳定
- 计数排序 稳定
- 计数排序 稳定

### 桶排序 

把数据划分到m个桶中，桶类进行快速排序；适用外部排序

桶内数据个数是k=n/m; 总时间复杂度是m*k*log^k=nlog^(n/m); m接近n时，log^(n/m)就足够小，时间复杂度就接近O(N)

### 计数排序

计数排序是桶排序的一种特殊情况，不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？

为了计算出每个数据在排序好的数组中的位置，需要借助一个计数器数组，如下图：

<img src="/img/sturct/jishu.jpg" alt="jishu" style="zoom:50%;" />



总结一下，计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。



### 基数排序

对待排序的数据按位进行拆分，然后做计数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了



## 二分查找

二分查找的效率特别高，41亿个数，使用二分查找，仅需要32次

时间复杂度：log^n

空间复杂度：O(1)

使用条件：

- 依赖顺序表结构，就是数组
- 依赖有序数据
- 用在插入、删除操作不频繁的场景
- 数据量太小，不适用二分查找；有个例外，如果比较操作比较耗时，比如300个字符串的比较，还可以适用二分查找
- 数据量太大，不适用二分查找；底层依赖数组，要求内存连续

适用二分查找的大部分情况都可以用散列表和二分查找树来实现，即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？

二分查找更适合用在“近似”查找问题，如：查找IP地址对应的省市地址，在这类问题上，二分查找的优势更加明显。用其他数据结构，比如散列表、二叉树，就比较难实现了。

## 跳表

链表加多级索引的结构,如下图

![skiplist](/img/sturct/skiplist.jpg)

时间复杂度：log^n

空间复杂度：O(n)

和二分查找比较：

- 不基于数组，基于链表
- 可以高效的插入、删除 时间复杂度是O(Log^N)  更新索引通过一个随机函数得到层级
- 耗费了更多的空间

和红黑树比较：

- 代码实现简单
- 范围查找更高效

## 散列表

散列冲突的解决办法：

- 开放寻址法；核心思想是如果出现了hash冲突再次进行探测；特别需要注意删除元素的时候不能置空，要置为deleted,否则查找会失效

  - 线性探测法：hash(K)+0;hash(K)+1;hash(K)+2;.........;查找的时候通过同样的方式探测，比较值是否相等，不等继续探测，直到遇到空槽；
  - 二次探测：hask(K)+0^2;hask(K)+1^2;hask(K)+2^2;hask(K)+3^2;.....
  - 双重探测：hask(K);hask(K)+hask(K);hask(K)+hask(K)+hask(K)......;..........

  使用限制：装载因子不能超过1

  优点：数据放在数组中，有利于CPU查询优化，序列化简单

  使用场景：当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因

- 链接法;

  优点：无装载因子限制

  使用场景：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表；java中的



扩容：散列表扩容普通思路是申请一个原数组两倍的空间，然后把原数组数据通过hash函数重新计算得到；这个过程比较耗时，可以进行优化，申请新数组的同时保留原先的数组，之后每次新增查找的时候通过hash函数挪一个数据到新数组，这个阶段查找的时候同时查新老数组

散列表优缺点：

优点：可以在O(1)的时间内访问数据

确定：无法顺序遍历数据

散列表设计注意点：

- 设计一个合适的散列函数；
- 定义装载因子阈值，并且设计动态扩容策略；
- 选择合适的散列冲突解决方法。



## 散列表+链表

java中LinkedHashMap

散列表：可以在O(1)访问数据，但数据存储位置是随机的

链表：数据访问时间是O(n),数据可以按顺访问

所以经常使用散列表+链表，可以取二者的优点，既能在O(1)时间内访问到数据，又可以按顺序访问数据

<img src="/img/sturct/hash_list.jpg" alt="hash_list" style="zoom:50%;" />

## 哈希算法

应用场景

- 唯一标识，对大数据做信息摘要，图片信息摘要
- 用于校验软件的完整性和安全性，软件的下载
- 安全加密，MD5,SHA256等散列算法，对应的加密算法有对称加密DES、AES,非对称加密RSA、DSA
- 散列函数
- 负载均衡，
- 数据分片
- 分布式存储，一致性哈希算法

## 一致性哈希算法

普通的哈希算法中，查找数据存储的位置通过对哈希值求余取模，但是在分布式环境中，新增一台机器和挂掉一台机器后要迁移所有机器的数据，成本太大，所以就需要一致性哈希算法；

基本思想是：把哈希空间分成m份（m远大于机器数n,如2^32）,使用相同的算法计算机器唯一标识和数据；沿着环走放到第一个遇到的机器上

<img src="/img/sturct/yizhi_hash.jpg" alt="yizhi_hash" style="zoom:50%;" />

虚拟节点：从上图我们可以看出来，当机器节点较少时，会发生数据倾斜，大量的数据都被放到同一台机器上；为了解决这个问题，引入虚拟节点，即对一个机器节点进行多次哈希 得到多个哈希节点

## 二叉树

高度 深度 层次

满二叉树：每个非叶子节点都有两个子节点

完全二叉树：每个非叶子节点都有左子树，满二叉树是一种特殊的完全二叉树

###  存储方式

- 链式存储，简单易懂
- 数组存储，节省空间
  - 左子树的位置是2i
  - 右子树的位置是2i+1
  - 父节点的位置是i/2

### 遍历

- 前序遍历  preOrder(r)=print r -> preOrder(r->left)->preLeft(r->right)
- 中序遍历  inOrder(r)= inOrder(r->left)->print r ->inLeft(r->right)
- 后序遍历  postOrder(r)= postOrder(r->left) ->postLeft(r->right) ->print r

## 二叉查找树

特点：值 左>根>右

缺点：不稳定，可能退化成链表

## 平衡二叉查找树 AVL树we

特点：是二叉查找树；自平衡，不会退化成链表

缺点：自平衡过程比较耗时

## 红黑树

特点：是二叉平衡查找树，不会退化成链表；非完美平衡；如何去做树的平衡，让树既不会让树倾斜严重又不会耗费太多的时间在平衡上；红黑树的出现是为了通过一系列设定好的规则来让程序知道怎么去维护这个平衡，

要满足的要求：

- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NIL），叶子节点不存储数据
- 每个任何相邻的节点不能同时为红色；通过节点变色实现
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑节点； 通过左旋、右旋实现；

主要操作：左旋 右旋  变色

插入：

**红黑树规定插入的节点必须是红色的**

插入操作只需要记住下面固定的三种case对应的操作就行了

- **CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色**，我们就依次执行下面的操作：将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；将关注节点 a 的祖父节点 c 的颜色设置成红色；关注节点变成 a 的祖父节点 c；跳到 CASE 2 或者 CASE 3。

- **CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色**，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：关注节点变成节点 a 的父节点 b；围绕新的关注节点b 左旋；跳到 CASE 3。

- **CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色**，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：围绕关注节点 a 的祖父节点 c 右旋；将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。调整结束。

  

删除：

删除操作比插入复杂，分为两步

- 针对删除节点做初步调整，节点删除后仍然满足最后一条规则，这时候会出现红-黑，黑-黑节点，因为不知道子树有多少黑色节点，为了满足最后一条规则临时把某些节点特殊处理；也是有固定的三个case对应的操作
  - **CASE 1：如果要删除的节点是 a，它只有一个子节点 b**，那我们就依次进行下面的操作：删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；调整结束，不需要进行二次调整。
  - **CASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c**。我们就依次进行下面的操作：如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；然后把节点 c 的颜色设置为跟节点 a 相同的颜色；如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。
  - **CASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点**，我们就依次进行下面的操作：找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；将节点 a 替换成后继节点 d；把节点 d 的颜色设置为跟节点 a 相同的颜色；如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。
  - 
- 针对关注节点进行二次调整，经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。有以下固定的4种case对应的操作
  - **CASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的**，我们就依次进行下面的操作：围绕关注节点 a 的父节点 b 左旋；关注节点 a 的父节点 b 和祖父节点 c 交换颜色；关注节点不变；继续从四种情况中选择适合的规则来调整。
  - **CASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的**，我们就依次进行下面的操作：将关注节点 a 的兄弟节点 c 的颜色变成红色；从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；关注节点从 a 变成其父节点 b；继续从四种情况中选择符合的规则来调整。
  - **CASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色**，我们就依次进行下面的操作：围绕关注节点 a 的兄弟节点 c 右旋；节点 c 和节点 d 交换颜色；关注节点不变；跳转到 CASE 4，继续调整。
  - **CASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的**，我们就依次进行下面的操作：围绕关注节点 a 的父节点 b 左旋；将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；将关注节点 a 的父节点 b 的颜色设置为黑色；从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。

为什么规定叶子节点都是黑色的空节点：

就是为了上述的几种case都是固定只有这几种

适用场景：凡是用到动态插入 删除等都可以用红黑树；但是红黑树自己实现比较复杂，如果需要自己实现可以选择跳表

和散列表对比：

- 性能稳定
- 无须考虑如何去设计散列函数
- 散列表是无序存储，而红黑树可以按顺序输出

和跳表对比：

- 占用较少的存储空间

总结：

- **把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性**。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。
- **找准关注节点，不要搞丢、搞错关注节点**。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。
- **插入操作的平衡调整比较简单，但是删除操作就比较复杂**。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。

## 堆

- 完全二叉树
- 堆中每个节点的值必须大于等于或小于等于左右子树的值

存储：

- 由于是完全二叉树，底层存储结构是数组，最省空间
- 左子树：2*i,右子树：2*i+1,根：i/2, 第一个非叶子节点 length/2

与快速排序比：

- 数据读取不是顺序的，不利于CPU缓存
- 同样数据，堆排序的次数要多于快速排序
- 和快速排序的时间复杂度一样
- 比快速排序稳定
- 插入删除效率高

使用场景：

- 堆排序，特别是动态数据的场景，优于快速排序
- TOP K问题
- 中位数,维护两个堆
- 优先队列

## 图

存储：

- 邻接矩阵（二维数组）
- 一维数组+链表，类似散列表，链表也可以升级为树

解决图的问题几种方式：

- 图，内存中
- 关系型数据库， 图需要持久化时
- 图数据库 graphsql,图特别大，需要经常进行图相关计算

两种遍历方式：

> 关键变量：int[ ] pre,pre[3]=2表示到达3这个节点的前一个节点是2，这样倒序遍历pre就可以找到路径
>
> 和树的广度深度遍历的不同是树的每个节点入度都是1，而图节点的入度大于1，所以要借助pre这样的数组来巧妙解决

- 广度优先遍历
- 深度优先遍历

## 字符串匹配算法

### 用途

- 信息检索- 文本编辑器中文字查找、indexOf、数据库搜索、搜索引擎的搜索
- 生物工程

### 算法种类

#### 单模式串匹配

- BF- Brute Force 暴力搜索算法 也叫朴素匹配算法

  模式串和主串的每一个子串进行比较 时间复杂度是O(n*m),m为子串的长度

- RK

  为了解决模式串中m个字符对比耗时过长，引入哈希算法，把m次比较减少到一次

  以下两种hash算法，假设都是26位字母

  - 设计一个26进制，a=1....z=26,如cba=`3*26*26`+2*26+1计算出对应子串的整型值；好处：不会出现hash冲突，缺点：模式串过长会出现hash值超过整型最大值
  - a=1....z=26，hash值等于数字相加cba=3+2+1; 好处：简单，不会超过整型最大值；缺点：会出现hash冲突

BF和RK算法都属于暴力搜索算法，用在两个比较短的字符串查找可以如Java中的字符串的IndexOf,但是当主字符串长短特别长的时候效率就会很低，如编辑器中的文本查找功能，所以有了BM、KMP算法

- BM- Boyer-Moore算法

   性能是KMP算法的3-4倍，但是实现起来复杂

  匹配按照模式串下标从大到小的顺序，倒着匹配的

  <img src="/img/sturct/stringmatch-bm.jpg" alt="stringmatch-bm" style="zoom:50%;" />

  - 坏字符规则。

    规则：把坏字符对应的模式串中的字符下标记作 si，如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi（如果存在多个，取index大的）。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。

    问题：si-xi可能出现负值，如主串aaaaaaaa，模式串ba,所以还需要借助另外一个好后缀规则

  - 好后缀规则

    规则：上图的bc是好后缀，记着{u}，这个时候如何移动呢，分两种情况;

    - 如果好后缀在模式串中存在，就将模式串滑动到子串{u*}与主串中{u}对齐的位置;

    - 如果好后缀在模式串中不存在，我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。如果好后缀的后缀子串在模式串的前缀子串中也找不到匹配的，就向后移动模式子串的长度位

      <img src="/img/sturct/stringmatch-bm1.jpg" alt="stringmatch-bm1" style="zoom:50%;" />

    **如何选择用坏字符规则还是好后缀规则？**

    分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数

  

- KMP

  匹配按照模式串下标从小到大的顺序，顺序匹配的

  核心思想是对已经比较过的好前缀，遇到坏字符的时候，找到一些规律，让已经比较过的好前缀不再进行比较，模式串能够一次新移动多位，即改变j的值，不从0开始比较了

  - 坏字符规则，同BM

  - 好前缀规则

    拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。

    假设在后缀子串中，查找不到可以跟好前缀子串匹配的，那么j还原成0，i+

  **如何来求好前缀的最长可匹配前缀和后缀子串呢?**

  在模式串中找到所有的候选好前缀子串，可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为 next 数组；如下图示例：

  <img src="/img/sturct/stringmatch-bm2.jpg" alt="stringmatch-bm2" style="zoom:24%;" />

  在每次比较之前，判断如果j>0,并且a[i]!=b[j]的时候去遍历next，用next中哪个呢，就判断next中存的值+1 为下标在b中的值是否等于a中下标为i的值，等就是要找的，不等j--继续找，最终也找不到j=0,i++

#### 多模式串匹配

  匹配多个模式串

- Trie树 也叫字典树

  **Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起**

  使用场景：前缀匹配查找，如单词自动补全、搜索引擎关键词提示

  不适用场景：精准查找，可使用红黑树等

- AC自动机  aho-corasick

  Trie树的升级版

  使用场景：敏感词过滤系统

# 算法思想

## 贪心算法（greedy algorithm）

核心思想：是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的[算法](https://zh.wikipedia.org/wiki/算法)

问题：贪心法容易**过早做决定**，因而没法达到最佳解

### 应用

霍夫曼编码（huffman coding）、Prim和Krusal最小生成树、Dijkstra单源最短路径、教师排课

## 分治（divide and conquer）

核心思想：分而治之，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解

应用：快速排序、归并排序、Google的MapReduce

## 回溯算法

核心思想：

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走

和递归的区别：

回溯是一种思路，递归是一种编程技巧；回溯算法基本上都是通过递归来实现

经典问题：

数独、八皇后、0-1背包、图的着色、旅行商问题、全排列

回溯算法的优化：

备忘录模式，记录已经处理的过程结果，后续用的时候直接拿来用不用再计算。

## 动态规划

核心思想：基本思路还是回溯的枚举，只是在枚举的过程中根据已枚举的结果来动态规划（如记录已经处理的过程结果，剔除肯定不是最优的路径）后续的结果。

### 动态规划的推导

**0-1背包问题，n个物品放到一个背包中，背包承重最大w,求最大能装物品重量**

1.通过回溯解决，f(i,cw),i是物品的序号，cw是放入后背包的的总重量；f(i,cw)=max{f(i+1,cw),f(i+1,cw+wigth[i])}调用过程如下图

<img src="/img/sturct/huisu01.jpg" alt="huisu01" style="zoom:50%;" />

2.f(2,2)被计算多次，可以记录下来备用；即为备忘录模式

**0-1背包问题，n个物品放到一个背包中，背包承重最大w,求最大能装物品总价值**

1.通过回溯解决，f(i,cw,cv),i是物品的序号，cw是放入后背包的的总重量,cv是背包里物品总价值；f(i,cw,cv)=max{f(i+1,cw,cv),f(i+1,cw+wigth[i],cv+value[i])}调用过程如下图

<img src="/img/sturct/dongtai01.jpg" alt="dongtai01" style="zoom:50%;" />

2.由于value不同，发现没法复用；但是明细f(2,2,4)的结果要比f(2,2,3)要优，所以可以直接舍弃f(2,2,3)不再往后进行，这就是动态规划

### 什么样的问题可以用动态规划来解决

- 多阶段最优解模型

  我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

- 最优子结构

  最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

- 无后效性

  无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

- 重复子问题

  不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

### 动态规划两种解题思路

- 状态转移表法

  具体解题思路如下

  - 先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树
  - 从递归树看是否存在重复子问题，如果存在两种解决方式，1.备忘录法 2 状态转移表法

  状态转移表法步骤：

  - 画一个状态表，二维的，其中，每个状态包含三个变量，行、列、数组值
  - 根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态
  - 我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。

- 状态转移方程法

# 高级算法

## 拓扑排序

- Kahn算法
- 深度优先遍历

应用场景： 确定代码源文件依赖关系

## 最短路径算法- 迪杰斯特拉(Dijkdtra)算法 

应用场景：地图

算法思路：

## 位图

**布隆过滤器**，在位图的基础的增加多次hash计算；节省空间，有误判

应用场景：爬虫过滤URL

## 概率统计-朴素贝叶斯算法

应用场景：垃圾短信、垃圾邮件过滤

## 欧几里得距离（Euclidean distance）

应用场景：推荐系统

## A*搜索算法

应用场景：游戏里人物自动从一个位置到另外一个位置

# 思考

本质上数据结构只有两种，数组和链表；其他的数据结构都是通过数组和链表实现，目的就是解决特定问题时可以更快、更方便，更不容易出错（通过加限制）

# 一些技巧

## 空间换时间

- 跳表的索引
- **散列表扩容，为提高效率新老空间同时保存**
- 计数排序的计数器数组
- 一致性哈希算法

## 时间换空间

## 分治

- 快速排序
- 归并排序(合并排序)
- 桶排序

## 快慢指针

- 快速排序 根据基准数把数组分成大小两段，正常思路是申请两个临时数组，然后合并；使用快慢两个指针i,j节省了另个临时数组空间
- 检测链表的环

## 哈希环

在哈希表中找数据的位置，通常的做法拿对象的hash值对总大小求余；但是这种方法的问题是当hash空间大小发生变化时，要重新迁移全部数据，数据量大的时候很耗时；

为了解决这种问题，引入了一致性hash算法，一个哈希环分成2^63次方个槽位，节点通过哈希函数分布到不同槽位上；

这个方法有个问题是节点少时容易发生数据倾斜，解决办法是把节点多哈希几次，增加节点在环上的个数

## 回溯思想






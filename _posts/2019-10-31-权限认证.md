---
layout: post
title: "权限认证"
subtitle: '权限认证'
comments: false
author: "Gump"
header-style: text
date: 2019-10-31 20:30:21 +0800
tags:
  - 架构
--- 


##  权限认证框架

### shiro

#### Terminology you’ll need

- **Subject** - Security specific user ‘view’ of an application user. It can be a human being, a third-party process, a server connecting to you application, or even a cron job. Basically, it is anything or anyone communicating with your application.
- **Principals** - A subjects identifying attributes. First name, last name, social security number, username
- **Credentials** - secret data that are used to verify identities. Passwords, Biometric data, x509 certificates,
- **Realms** - Security specific DAO, data access object, software component that talks to a backend data source. If you have usernames and password in LDAP, then you would have an LDAP Realm that would communicate with LDAP. The idea is that you would use a realm per back-end data source and Shiro would know how to coordinate with these realms together to do what you have to do.

####  [Authentication Sequence](https://shiro.apache.org/authentication.html#authentication-sequence)

**Step 1**: Application code invokes the `Subject.login` method, passing in the constructed `AuthenticationToken` instance representing the end-user’s principals and credentials.

**Step 2**: The `Subject` instance, typically a [`DelegatingSubject`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/support/DelegatingSubject.html) (or a subclass) delegates to the application’s `SecurityManager` by calling `securityManager.login(token)`, where the actual authentication work begins.

**Step 3**: The `SecurityManager`, being a basic ‘umbrella’ component, receives the token and simply delegates to its internal [`Authenticator`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html)`instance by calling`authenticator.[`authenticate(token)`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html#authenticate-org.apache.shiro.authc.AuthenticationToken-). This is almost always a [`ModularRealmAuthenticator`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/ModularRealmAuthenticator.html) instance, which supports coordinating one or more `Realm` instances during authentication. The `ModularRealmAuthenticator` essentially provides a [PAM](https://en.wikipedia.org/wiki/Pluggable_Authentication_Modules)-style paradigm for Apache Shiro (where each `Realm` is a ‘module’ in PAM terminology).

**Step 4**: If more than one `Realm` is configured for the application, the `ModularRealmAuthenticator` instance will initiate a multi-`Realm` authentication attempt utilizing its configured [`AuthenticationStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html). Before, during and after the `Realms` are invoked for authentication, the `AuthenticationStrategy` will be called to allow it to react to each Realm’s results. We will cover `AuthenticationStrategies` soon.

**Step 5**: Each configured `Realm` is consulted to see if it [`supports`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#supports-org.apache.shiro.authc.AuthenticationToken-) the submitted `AuthenticationToken`. If so, the supporting Realm’s [`getAuthenticationInfo`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#getAuthenticationInfo-org.apache.shiro.authc.AuthenticationToken-) method will be invoked with the submitted `token`. The `getAuthenticationInfo` method effectively represents a single authentication attempt for that particular `Realm`. We will cover the `Realm` authentication behavior shortly.

#### [AuthenticationStrategy](https://shiro.apache.org/authentication.html#authenticationstrategy)

| `AuthenticationStrategy` class                               | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [`AtLeastOneSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.html) | If one (or more) Realms authenticate successfully, the overall attempt is considered successful. If none authenticate succesfully, the attempt fails. |
| [`FirstSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.html) | Only the information returned from the first successfully authenticated Realm will be used. All further Realms will be ignored. If none authenticate successfully, the attempt fails. |
| [`AllSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AllSuccessfulStrategy.html) | All configured Realms must authenticate successfully for the overall attempt to be considered successful. If any one does not authenticate successfully, the attempt fails. |

#### Session

**Features**

- **POJO/J2SE based (IoC friendly)** - Everything in Shiro (including all aspects of Sessions and Session Management) is interface-based and implemented with POJOs. This allows you to easily configure all session components with any JavaBeans-compatible configuration format, like JSON, YAML, Spring XML or similar mechanisms. You can also easily extend Shiro’s components or write your own as necessary to fully customize session management functionality.
- **Easy Custom Session Storage** - Because Shiro’s Session objects are POJO-based, session data can be easily stored in any number of data sources. This allows you to customize exactly where your application’s session data resides - for example, the file system, in memory, in a networked distributed cache, a relational database, or proprietary data store.
- **Container-Independent Clustering!** - Shiro’s sessions can be easily clustered using any of the readily-available networked caching products, like Ehcache + Terracotta, Coherence, GigaSpaces, et. al. This means you can configure session clustering for Shiro once and only once, and no matter what container you deploy to, your sessions will be clustered the same way. No need for container-specific configuration!
- **Heterogeneous Client Access** - Unlike EJB or Web sessions, Shiro sessions can be ‘shared’ across various client technologies. For example, a desktop application could ‘see’ and ‘share’ the same physical session used by the same user in a web application. We are unaware of any framework other than Shiro that can support this.
- **Event Listeners** - Event listeners allow you to listen to lifecycle events during a session’s lifetime. You can listen for these events and react to them for custom application behavior - for example, updating a user record when their session expires.
- **Host Address Retention** – Shiro Sessions retain the IP address or host name of the host from where the session was initiated. This allows you to determine where the user is located and react accordingly (often useful in intranet environments where IP association is deterministic).
- **Inactivity/Expiration Support** – Sessions expire due to inactivity as expected, but they can be prolonged via a `touch()` method to keep them ‘alive’ if desired. This is useful in Rich Internet Application (RIA) environments where the user might be using a desktop application, but may not be regularly communicating with the server, but the server session should not expire.
- **Transparent Web Use** - Shiro’s web support fully implements and supports the Servlet 2.5 specification for Sessions (`HttpSession` interface and all of it’s associated APIs). This means you can use Shiro sessions in existing web applications and you don’t need to change any of your existing web code.
- **Can be used for SSO** - Because Shiro session’s are POJO based, they are easily stored in any data source, and they can be ‘shared’ across applications if needed. We call this ‘poor man’s SSO’, and it can be used to provide a simple sign-on experience since the shared session can retain authentication state.

#### SSO

> Shiro-CAS support is deprecated, support has been moved to the Apache Shiro based [buji-pac4j](https://github.com/bujiio/buji-pac4j) project.

### pacj4

### spring security

## 用户认证方案

### OAuth

使用场景：使用第三方账号访问网站资源是使用;临时授权 部分授权 取消授权

缺点：协议复杂

### SAML

### CAS

使用场景：单点登录 session+ticket

### OPENID CONNECT(OAuth+OPENID)

### HTTP（Session）

### OPENID

### JWT

使用场景：restful api 无状态的接口，常用在移动端接口

## 单点的登录方案(对比)
> https://www.sojson.com/blog/80.html，https://yq.aliyun.com/articles/636281

### cookie  

>优点：web应用天然支持实现简单；缺点：无法解决cookie跨域问题,如果只是跨子域可以用cookie

### jwt

>  特点：无状态;缺点：确定无法管理登录状态 无法强制token失效,认证服务器压力大

### Cas

> https://yq.aliyun.com/articles/636281 结合了cookie和jwt的优点










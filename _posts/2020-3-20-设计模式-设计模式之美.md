---
layout: post
title: "设计模式之美"
subtitle: '学习笔记'
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 学习笔记 
    - 设计模式
---

# 设计模式--设计模式之美学习笔记

## 总览

![design1](../img/design/design1.png)

- 设计模式主要是解决提高代码的可扩展性
- 编程规范主要是解决代码的可读性

## 抽象类和接口

- 抽象类为了代码的复用  is-a关系  自下而上，子类重复了抽象出父类
- 接口是为了解耦 has-a关系  自上而下，先定义接口后考虑实现

## 组合优于继承

组合可以解决继承层次过多，方法追随困难

## 设计原则

SOLID、KISS、YAGNI、DRY、LOD

### Single Responsibility Principle-SRP 单一职责

要看具体的业务场景

### Open Closed Principle-OCP 开闭原则

只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。

最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

### Liskov Substitution Principle-LSP 里式替换

子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

最核心的就是理解“design by contract“

### Interface Segregation Principle-ISP 接口隔离原则

客户端不应该强迫依赖它不需要的接口

### Dependency Inversion Principl-DIP 依赖反转原则

高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

相似概率：

- 控制反转

  控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。流程的控制权从程序员“反转”给了框架。

- 依赖注入

  赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

- 依赖注入框架

  由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

  比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。

  Spring 框架自己声称是控制反转容器（Inversion Of Control Container）IOC。

  

以上原则简称SOLID原则

### KISS原则

Keep It Simple and Stupid.尽量保持简单。

- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。
-  不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。不要过度优化。
-  不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

### YAGNI 原则

You Ain’t Gonna Need It

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。

### DRY 原则

Don’t Repeat Yourself

- 实现逻辑重复
- 功能语义重复
- 代码执行重复

怎么提高代码复用性？

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模板等设计模式

### 迪米特法则 

Law of Demeter -LOD 

它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。

每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

基于最小接口而非最大实现编程

- 高内聚

  就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。

- 松耦合

  类与类之间的依赖关系简单清晰

## 重构

软件设计大师 Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。

### 单元测试

- 保证重构不出错的重要手段是 **单元测试** 

- 对于单元测试，我们需要建立以下正确的认知：
  - 编写单元测试尽管繁琐，但并不是太耗时；
  - 我们可以稍微放低对单元测试代码质量的要求;
  - 覆盖率作为衡量单元测试质量的唯一标准是不合理的；
  - 单元测试不要依赖被测代码的具体实现逻辑；
  - 单元测试框架无法测试，多半是因为代码的可测试性不好。
- 常见的测试不友好的代码有下面这 5 种:
  - 代码中包含未决行为逻辑
  - 滥用可变全局变量
  - 滥用静态方法
  - 使用复杂的继承关系
  - 高度耦合的代码

### 解耦

重构一个有效手段是 解耦

- 代码是否需要“解耦”？

​      间接的衡量标准有很多，比如，看修改代码是否牵一发而动全身。直接的衡量标准是把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。

- 如何给代码“解耦”？

  给代码解耦的方法有：封装与抽象、中间层、模块化，以及一些其他的设计思想与原则，比如：单一职责原则、基于接口而非实现编程、依赖注入、多用组合少用继承、迪米特法则等。当然，还有一些设计模式，比如观察者模式。

### 编码规范

#### 命名

- 命名多长最合适

  对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。

- 利用上下文简化命名

  User类中名称命名name而不是UserName

- 命名要可读、可搜索

  “可读”，指的是不要用一些特别生僻、难发音的英文单词来命名。

  搜索，指的是IDE的自动补全

#### 注释

类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

#### Code Style
- 类 函数的大小

对于函数代码行数的最大限制，那就是不要超过一个显示屏的垂直高度。

一行代码最长不能超过 IDE 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读

- 善用空行分割单元块

- 四格缩进还是两格缩进？

  个人比较推荐使用两格缩进，这样可以节省空间。

  值得强调的是，不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进

### 提高代码可读性

- 把代码分割成更小的单元块
- 避免函数参数过多
  - 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数
  - 将函数的参数封装成对象
- 勿用函数参数来控制逻辑
- 函数设计要职责单一
- 移除过深的嵌套层次
  - 去掉多余的 if 或 else 语句
  - 使用编程语言提供的 continue、break、return 关键字，提前退出嵌套
  - 将部分嵌套逻辑封装成函数调用，以此来减少嵌套。
  - 使用多态来替代 if-else、switch-case 条件判断的方法
- 学会使用解释性变量
  - 常量取代魔法数字
  - 使用解释性变量来解释复杂表达式

### 如何发现代码质量问题？

#### 非功能性需求

- 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？
- 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
- 设计模式是否应用得当？是否有过度设计？
- 代码是否容易扩展？如果要添加新功能，是否容易实现？
- 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
- 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
- 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

#### 代码实现是否满足业务本身特有的功能和非功能需求

- 代码是否实现了预期的业务需求？
- 逻辑是否正确？是否处理了各种异常情况？
- 日志打印是否得当？是否方便 debug 排查问题？
- 接口是否易用？是否支持幂等、事务等？
- 代码是否存在并发问题？是否线程安全？
- 性能是否有优化空间，比如，SQL、算法是否可以优化？
- 是否有安全漏洞？比如输入输出校验是否全面？

### 分阶段持续重构

- 第一轮重构：提高代码的可读性
- 第二轮重构：提高代码的可测试性
- 第三轮重构：编写完善的单元测试
- 第四轮重构：所有重构完成之后添加注释

## 程序如果是非期望返回结果怎么返回

- NULL

  返回NULL还是异常，要看是异常行为还是正常行为；比如搜索接口，查不到数据是正常行为，应该返回NULL而不是异常；比如获取当前机器IP接口，获取不到就是异常，要抛出异常

- 异常

  异常是原样返回还是包装成一个新的异常；要看这个异常上层业务是否能够理解

- 空对象

- 错误码

# 设计模式

## 单例

### 用途

- 处理资源访问冲突

  如Logger类

- 表示全局唯一类

  如IDGenerater类、配置类、连接池类

### 单例的实现

- 饿汉模式
- 懒汉模式
- 双重检测 double check
- 静态内部类
- 枚举

### 线程单例，集群单例

线程单例：通过HashMap,key存线程Id; instances.putIfAbsent(currentThreadId, new IdGenerator());

集群单例：通过Reids全局锁，拿到锁后的实例从reids load对象反序列化

### 问题

- 单例对 OOP 特性的支持不友好
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数

### 单例替代方案

- 静态方法
- 工厂模式
- IOC容器

## 工厂模式

工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。

实例：Calendar、DateFormat、Spring BeasFactory

三种工厂模式

1. 简单工厂（Simple Factory）
     使用场景：
      a. 当每个对象的创建逻辑都比较简单的时候，将多个对象的创建逻辑放到一个工厂类中。
     实现：
      a. if else 创建不同的对象。
      b. 用单例模式 + 简单工厂模式结合来实现。
2. 工厂方法（Factory Method）
        使用场景：
         a. 当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类时，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。
         b. 避免很多 if-else 分支逻辑时。
        实现：
         a. 定义相应的ParserFactory接口，每个工厂定义一个实现类。这种方式使用会有多个if else 让使用更加复杂。
         b. 创建工厂的工厂来，此方案可以解决上面的问题。
3. 抽象工厂（Abstract Factory）- 不常用
           使用场景：
            a. 有多种分类方式，如方式要用一套工厂方法，方式二要用一套工厂方法，详见原文例子。
           实现：
            让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。

判断要不要使用工厂模式的标准
一、封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
二、代码复用：创建代码抽离到独立的工厂类中可以复用
三、隔离复杂性：可以封装复杂的创建逻辑
四、控制复杂度：将创建代码抽离出来，让原本的函数或是类职责更单一，代码更简洁

## 建造者模式

建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。

什么时候使用建造者模式：

如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。

- 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。

与工厂模式的区别：

  工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象；

  建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象  

## 原型模式

如果对象的创建成本比较大(需要经过排序、Hash、网络IO、磁盘IO才能等到)，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称**原型模式**。

## 代理

### 应用场景

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。课堂讨论

- 静态代理
- 动态代理
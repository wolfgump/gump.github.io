---
layout: post
title: "Java核心知识点"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - Java 
    - 笔记
---

# JAVA-- 核心知识点

## volatile

https://www.ibm.com/developerworks/cn/java/j-jtp06197.html

## Optional

Optional.orElse() 包含了get

## SPI

### why

面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制

### 实现

在jdk6里面引进的一个新的特性ServiceLoader，从官方的文档来说，它主要是用来装载一系列的service provider。而且ServiceLoader可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。

ServiceLoader可以加载不同jar下的META-INF/services/

### 应用场景

- dubbo 里的扩展点 https://dubbo.apache.org/zh-cn/docs/dev/SPI.html
- 数据库驱动
- Eclipse、idea 的插件

### 双亲委派模型

当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。

## HashMap

hash算法：

```java
//计算Hash
static final int hash(Object key) {
        int hash;
        return key == null ? 0 : (hash = key.hashCode()) ^ hash >>> 16;
 }
//计算Index
int index = hash(key) & (capacity - 1)
```

求Hash:

获取对象的hashcode以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode >>> 16)，这一步甚是巧妙，是将高16位移到低16位，这样计算出来的整型值将“具有”高位和低位的性质;

求Index:

因为 A % B = A & (B - 1),前提是B的大小是2的n次方；所以，(h ^ (h >>> 16)) & (capitity -1) = (h ^ (h >>> 16)) % capitity，可以看出这里本质上是使用了「除留余数法」

## ThreadLocal

存在的意义：

线程间的数据共享，原先的方法就要定义一个Map<Thread,Value>,这么做对同一个Map多线程访问，会有锁竞争，并发能力差

数据结构：

<img src="/img/java/threadlocal.png" alt="threadlocal" style="zoom:80%;" />

**引用关系**

- Thread 对ThreadLoacalMap强引用
- ThreadLocalMap对Entry强引用
- Entry对Key(ThreadLocal) 弱引用
- Entry对Value强引用
- 外部变量对Key(ThreadLocal)强引用

**弱引用：**

ThreadLocalMap对Entry的Key(ThreadLocal 类型)是弱引用，当程序中不再用到ThreadLocal时，此时只剩ThreadLocalMap的弱引用，会被回收掉；即外部变量对Key(ThreadLocal)的强引用断开后，Key(ThreadLocal)在堆上的空间在GC的时候会被回收掉；

这样做的好处是在一个线程周期内如果发生了内存不够用，触发GC会议回收掉不再使用的ThreadLocal

**为什么会出现内存泄漏**

ThreadLocalMap对Entry的Value引用是强引用，如果线程一直不结束（比如线程被放到了线程池里），就会出现Entry无法被回收,Entry执行的Value无法被回收，如果Value比较大，就容易发生内存泄漏。

解决方案：在每次对Entry进行get set的时候都回去扫描一遍key=null的Entry,然后断掉ThreadLocalMap对这个Entry的引用；这么做不能彻底解决问题，最后一次set的值无法在key==null时被清除；**所以在线程调用完成时需要使用这主动调用一次remove**

**hash冲突：**

采用的是线性探测法解决

关键代码：

获取map: 直接获取当前线程的变量

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
//referent值得就是entry
public void clear() {
        this.referent = null;
    }
```

## 伪共享

一些高性能框架经常有下面的代码，为什么这么写呢？

```java
class LhsPadding
{
    protected long p1, p2, p3, p4, p5, p6, p7;
}

class Value extends LhsPadding
{
    protected volatile long value;
}

class RhsPadding extends Value
{
    protected long p9, p10, p11, p12, p13, p14, p15;
}
```

**Cache Line**
 现代CPU读取数据通常以一块连续的块为单位，即缓存行（Cache Line）。所以通常情况下访问连续存储的数据会比随机访问要快，访问数组结构通常比链结构快，因为通常数组在内存中是连续分配的。

缓存行的大小通常是64字节，这意味着即使只操作1字节的数据，CPU最少也会读取这个数据所在的连续64字节数据。

**缓存失效**
根据主流CPU为保证缓存有效性的MESI协议的简单理解，如果一个核正在使用的数据所在的缓存行被其他核修改，那么这个缓存行会失效，需要重新读取缓存。

**回答上面的问题**

假设有一个类A,有两个类变量long l1,long l2; l1和l2的更新相互不影响，但是他们会一次性被缓存行读取，修改l1,另外一个缓存了要修改l2的cpu里的缓存就行失效；所以在l1和l2的左右分别padding 7个long类型的变量，让l1和l2独自被缓存；拿空间换取时间

## 如何设置线程池大小

- CPU密集型 cpu核心数+1

  比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间

- IO密集型 cpu核心数*2

- 混合型

  线程数=N（CPU核数）*（1+WT（线程等待时间）/ST（线程时间运行时间））
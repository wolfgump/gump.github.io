---
layout: post
title: "权限认证"
subtitle: '权限认证'
comments: false
author: "Gump"
header-style: text
date: 2019-10-31 20:30:21 +0800
tags:
  - 架构
---


##  权限认证框架

### shiro

#### Terminology you’ll need

- **Subject** - Security specific user ‘view’ of an application user. It can be a human being, a third-party process, a server connecting to you application, or even a cron job. Basically, it is anything or anyone communicating with your application.
- **Principals** - A subjects identifying attributes. First name, last name, social security number, username
- **Credentials** - secret data that are used to verify identities. Passwords, Biometric data, x509 certificates,
- **Realms** - Security specific DAO, data access object, software component that talks to a backend data source. If you have usernames and password in LDAP, then you would have an LDAP Realm that would communicate with LDAP. The idea is that you would use a realm per back-end data source and Shiro would know how to coordinate with these realms together to do what you have to do.

####  [Authentication Sequence](https://shiro.apache.org/authentication.html#authentication-sequence)

**Step 1**: Application code invokes the `Subject.login` method, passing in the constructed `AuthenticationToken` instance representing the end-user’s principals and credentials.

**Step 2**: The `Subject` instance, typically a [`DelegatingSubject`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/support/DelegatingSubject.html) (or a subclass) delegates to the application’s `SecurityManager` by calling `securityManager.login(token)`, where the actual authentication work begins.

**Step 3**: The `SecurityManager`, being a basic ‘umbrella’ component, receives the token and simply delegates to its internal [`Authenticator`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html)`instance by calling`authenticator.[`authenticate(token)`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html#authenticate-org.apache.shiro.authc.AuthenticationToken-). This is almost always a [`ModularRealmAuthenticator`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/ModularRealmAuthenticator.html) instance, which supports coordinating one or more `Realm` instances during authentication. The `ModularRealmAuthenticator` essentially provides a [PAM](https://en.wikipedia.org/wiki/Pluggable_Authentication_Modules)-style paradigm for Apache Shiro (where each `Realm` is a ‘module’ in PAM terminology).

**Step 4**: If more than one `Realm` is configured for the application, the `ModularRealmAuthenticator` instance will initiate a multi-`Realm` authentication attempt utilizing its configured [`AuthenticationStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html). Before, during and after the `Realms` are invoked for authentication, the `AuthenticationStrategy` will be called to allow it to react to each Realm’s results. We will cover `AuthenticationStrategies` soon.

**Step 5**: Each configured `Realm` is consulted to see if it [`supports`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#supports-org.apache.shiro.authc.AuthenticationToken-) the submitted `AuthenticationToken`. If so, the supporting Realm’s [`getAuthenticationInfo`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#getAuthenticationInfo-org.apache.shiro.authc.AuthenticationToken-) method will be invoked with the submitted `token`. The `getAuthenticationInfo` method effectively represents a single authentication attempt for that particular `Realm`. We will cover the `Realm` authentication behavior shortly.

#### [AuthenticationStrategy](https://shiro.apache.org/authentication.html#authenticationstrategy)

| `AuthenticationStrategy` class                               | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [`AtLeastOneSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.html) | If one (or more) Realms authenticate successfully, the overall attempt is considered successful. If none authenticate succesfully, the attempt fails. |
| [`FirstSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.html) | Only the information returned from the first successfully authenticated Realm will be used. All further Realms will be ignored. If none authenticate successfully, the attempt fails. |
| [`AllSuccessfulStrategy`](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AllSuccessfulStrategy.html) | All configured Realms must authenticate successfully for the overall attempt to be considered successful. If any one does not authenticate successfully, the attempt fails. |

#### Filter

Default:FormAuthenticationFilter

![image-20200106101557885](/Users/ganshitao/Documents/Doc/markdown-image/image-20200106101557885.png)

#### Session

#### 工作流程

![image-20200106104313720](/Users/ganshitao/Documents/Doc/markdown-image/image-20200106104313720.png)

#### SSO

> Shiro-CAS support is deprecated, support has been moved to the Apache Shiro based [buji-pac4j](https://github.com/bujiio/buji-pac4j) project.

### pacj4

### spring security

## 用户认证方案

### OAuth

使用场景：使用第三方账号访问网站资源是使用;临时授权 部分授权 取消授权

缺点：协议复杂

### SAML

### CAS

使用场景：单点登录 session+ticket

### OPENID CONNECT(OAuth+OPENID)

### HTTP（Session）

### OPENID

### JWT

使用场景：restful api 无状态的接口，常用在移动端接口

## 单点的登录方案(对比)
> https://www.sojson.com/blog/80.html，https://yq.aliyun.com/articles/636281

### cookie  

>优点：web应用天然支持实现简单；缺点：无法解决cookie跨域问题,如果只是跨子域可以用cookie

### jwt

>  特点：无状态;缺点：确定无法管理登录状态 无法强制token失效,认证服务器压力大

### Cas

> https://yq.aliyun.com/articles/636281 结合了cookie和jwt的优点










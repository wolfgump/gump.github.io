---
layout: post
title: "深入拆解Java虚拟机"
subtitle: 'JVM'
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 学习笔记 
    - JVM
    - 笔记
---


# 总览

<img src="/img/jvm/overview.jpg" alt="overview" style="zoom:25%;" />

<img src="/img/jvm/partition.png" alt="partition" style="zoom:50%;" />

## 基本原理

### Java代码运行过程

- 编码源文件 xx.java

- 通过ClassLoader加载源文件，得到xx.class, class文件里存储的是Java字节码

- 将字节码翻译成机器码，机器码宿主机可以直接运行；字节码翻译成机器码有以下两种方式

  - 解释执行，即逐条将字节码翻译成机器码并执行
  - 即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。

  前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

  HotSpot 内置了多个即时编译器：C1、C2 和 Graal

  HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。


## 垃圾收集器

两个维度看垃圾收集器

- 并行（Parallel）:多个垃圾收集线程器线程同时工作，如ParaNew,ParaOld;对应的有串行（Serial）收集器
- 并发(Concurrent)：用户线程和垃圾收集线程同时工作，如CMS,G1

#### Serial、Serial Old

单线程；

Serial 新生代收集器，复制算法

Serial Old 老年代算法，标记-整理

#### ParNew、ParOld

分别是Serial和Serial Old对应的多线程版本

#### CMS-Concurrent Mark Sweep收集器（老年代算法）

四个阶段：

- 初始化标记（STW，单线程）：标记GC Root可以直接关联到的对象
- 并发标记（单线程）
- 重新标记（STW，多线程）:修正并发标记阶段因用户程序继续运行而导致**标记产生**变动的那一部分对象；只针对标记过的对象，不会重新GC ROOT
- 并发清除（单线程）

缺点：

- CPU资源敏感，并发阶段不会导致程序停顿，但会导致程序变慢
- 无法处理浮动垃圾；-XX:CMSInitiatingOccupancyFraction 老年代占比开始回收，设置过高容易产生”Concurrent Mode Failure“
- CMS是基于 标记-清除算法实现，会产生垃圾碎片； -XX：UseCMSCompactAtFullCollection 开启整理（默认开启） 但是会导致程序停顿；-XX:CMSFullGCsBeforCompaction 这个参数用于设置执行多少次不压缩的FullGC后跟一次压缩

#### G1- Garbage-First收集器（新生代，老年代）

   面向服务端应用的垃圾收集器。

  优先回收价值最大（时间短，释放内存多）的Region

特点：

- 并行与并发
- 分代收集
- 空间整合
- 可预测的停顿，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在堆垃圾收集上的时间不得超过N秒

四个阶段：

- 初始化标记（STW）

- 并发标记  

  -XX:InitiatingHeapOccupancyPercent 整个堆垃圾占比，达到触发并发标记

  `-XX:ConcGCThreads`来设置并发线程数，默认情况下，G1垃圾收集器会将这个线程总数设置为并行垃圾线程数（`-XX:ParallelGCThreads`）的四分之一。

- 最终标记

- 筛选回收

G1 Java堆内存布局与其他垃圾收集器差别很大，它将整个java堆分成多个大小相等的独立区域（Region）,还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离，他们都是一部分Region(不需要连续)

#### 现象

- 明明内存还够，但是触发了FullGc； 产生了内存碎片；办法：G1 -XX:G1HeapRegionSize 增大区大小，减少或消除巨型对象

- **并发标记周期开始后的FULL GC**

  ```logtext
  51.408: [GC concurrent-mark-start]
  65.473: [Full GC 4095M->1395M(4096M), 6.1963770 secs]
   [Times: user=7.87 sys=0.00, real=6.20 secs]
  71.669: [GC concurrent-mark-abort]
  ```

​       这说明针对老年代分区的回收速度比较慢，或者说对象过快得从新生代晋升到老年代，或者说是有很多大对象直接在老年代分配

​       办法：调大整个堆的大小、更快得触发并发回收周期、让更多的回收线程参与到垃圾收集的动作中。

- 在一次混合收集之后跟着一条FULL GC

  这意味着混合收集的速度太慢，在老年代释放出足够多的分区之前，应用程序就来请求比当前剩余可分配空间大的内存。

  办法：增加每次混合收集收集掉的老年代分区个数；增加并发标记的线程数；提高混合收集发生的频率。

- 在新生代垃圾收集快结束时，找不到可用的分区接收存活下来的对象

  ```text
  60.238: [GC pause (young) (to-space overflow), 0.41546900 secs]
  ```

  这意味着整个堆的碎片化已经非常严重了。

  1）增加整个堆的大小——通过增加`-XX:G1ReservePercent`选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量;（2）通过减少 `-XX:InitiatingHeapOccupancyPercent`提前启动标记周期；（3） 你也可以通过增加`-XX:ConcGCThreads`选项的值来增加并发标记线程的数目；

#### 调优

- 不要自己显式设置新生代的大小（用`Xmn`或`-XX:NewRatio`参数），如果显式设置新生代的大小，会导致目标时间这个参数失效。
- 由于G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整`-XX:MaxGCPauseMillis=N`参数，这也符合G1的目的——让GC调优尽量简单，这里有个取舍：如果减小这个参数的值，就意味着会调小新生代的大小，也会导致新生代GC发生得更频繁，同时，还会导致混合收集周期中回收的老年代分区减少，从而增加FULL GC的风险。这个时间设置得越短，应用的吞吐量也会受到影响。

最佳实践

- -XX:+UseG1GC，告诉JVM使用G1垃圾收集器
- -XX:MaxGCPauseMillis=200，设置GC暂停时间的目标最大值，这是个柔性的目标，JVM会尽力达到这个目标
- -XX:INitiatingHeapOccupancyPercent=45，如果整个堆的使用率超过这个值，G1会触发一次并发周期。记住这里针对的是整个堆空间的比例，而不是某个分代的比例。


#### 使用场景

 串行多线程的收集器适合用在客户端程序，允许短暂的停顿，但是较快的完整来及回收

 并行多线程适合用在服务端，追求最短的停顿时间

### 安全点

为了快速的找到GCRoot,在HotSpot中使用一组OopMap的数据结构来记录栈和寄存器中哪些位置是引用；

但是导致OopMap变化的指令比较多，只有在特定位置更新OopMap,这个位置是安全点；安全点的选定是以是否具有让程序长时间执行的特征（如方法调用、循环跳转、异常跳转）；安全点代码的插入是JVM来判断然后插入的；

在查找GCRoot时，需要所有线程都到达安全点，然后STW,再找GCROOT

## 类的加载

类加载机制：虚拟机把描述类的数据从**class文件** （不是java文件，从java到class要经过编译）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

类加载器：通过一个类的全限定名来获取描述此类的二进制字节流

### 类加载时机

java虚拟机规范中并没有进行强制约束；但是对于初始化阶段，虚拟机规范各严格规定了有且只有5种情况必须立即对类进行初始化（而加载、验证、准备需要在此之前开始）

- 遇到new、getstatic、putstatic、invokestatic
- 使用java.lang.reflect包的方法对类进行反射调用的时候
- 当初始化一个类的时候，如果发现其父类还没进行过初始化，则先触发其父类的初始化
- 当虚拟机启动时，用户需要指定一个执行的主类
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果...

#### 加载器类型

- BootStrap ClassLoader(启动类加载器)

  只加载%JAVA_HOME/jre

- Extension ClassLoader(扩展类加载器)

  %JAVA_HOME/jre/lib/ext

- APP ClassLoader(应用类加载器,也称为系统类加载器)

  CLASSPATH下的类库

用户自定义加载器 继承 APP 继承 Extension 继承 BootStrap

需要自定义加载器的场景：

- 从非CLASSPATH路径加载文件
- 从网络的远程加载文件
- 加载加密文件

### 双亲委派加载机制（非强制性约束）

 	定义：一个类加载器收到了类的加载请求，它首先把这个请求委派给父类加载器去完成，只有父类无法完成这个加载请求，子加载器才会尝试加载（注：父类根据全限定类名判断自己是否加载过，加载过就返回成功，没有加载过加返回无法加载）

  好处：保证了Java程序的稳定运作；如：类java.lang.Object,它放在%JAVA_HOME/jre/lib/rt.jar包类，由启动类加载器加载，任意地方定义再定义java.lang.Oject，都是由启动类加载器加载，保证了Object类的唯一

  缺点：应用类加载器会顺着双亲路径往上判断,直到启动类加载器.但是启动类加载器不会往下询问,这个委托路线是单向的,即顶层的类加载器,无法访问底层的类加载器所加载的类。

### 打破双亲委派加载机制

JDBC(https://www.jianshu.com/p/09f73af48a98)、SPI

### 类的加载实例

#### Tomcat

- tomcat如何做到部署多个web应用时不产生类冲突的

  tomcat自定义多个类加载器完成隔离；如Common类加载器加载/common/*,CatalinaCalssLoader加载/server/ *,WebappClassLoader加载 /webapp/WEB-INF/*

- tomcat 怎么做到不需要依赖具体的web应用就能启动各种web应用的

  tomcat和web应用都遵循同一个Servet协议；这种设计原则满足依赖接口编程不依赖具体的实现

- tomcat如何启动web应用的

  tomcat的主类是BootStrap类,当有请求过来，通过请求的路径找到对应的web应用目录，找到httpServet类进行类的加载调用

## 虚拟机的性能监控和故障处理工具

### 影响性能的关键因素

thread control, disk I/O, database access, network I/O, and garbage collection (GC).

工具介绍：https://www.alibabacloud.com/blog/jprofiler-best-practices-powerful-performance-diagnostic-tool_594958

### JDK自带工具

- jps:虚拟机进程状况工具

- jstat:虚拟机统计信息监视工具

- jmap:java堆内存映像工具

  用于排查堆内存溢出问题

- jstack:java堆栈跟踪工具；https://juejin.im/post/5b31b510e51d4558a426f7e9

  - 用来查找死锁
  - 排查CPU使用率高，找到对应线程
  - 响应慢或无响应
  
- JVisual 界面工具

### JDK外更先进的分析工具

- 堆分析工具

​       MAT、Perfma、JProfiler

- 栈分析工具

  Perfma、JProfiler

### 通过字节码增强不修改代码查看线上问题工具

- btrace
- Alibaba/arthas  功能全、部署简单
- Qunar/bistoury  有图形化界面，部署起来复杂

### 监控工具

- SkyWalking

###问题排查思路

首先看系统的负载，

- 如果是内存高

  用jmap去dump堆内存，然后使用MAT分析可能的内存泄漏；具体到代码层面考虑以下点：

  - 是否一次在数据或者网络加载了过多的数据，
  - 是否存在了磁盘/网络IO没有关闭，
  - 是否有用到类似ThreadLocal和线程池一起用没有remove

- 如果是CPU过高，

  用jstack去dump线程，对比多次dump文件的runnable线程、或借助JProfiler分析死锁;具体代码层面考虑：

  - 是否有死循环
  - 递归的层次是否太深或者没有出口
  - 是否有死锁

- 如果CPU利用持续率走低,接口响应慢 
  - 是否存在磁盘/IO阻塞
  - 网络IO是否未设置超时时间一直等待
  - 线程池里线程数量是否太少，如HttpClient的默认连接池只有2个
  - GC配置是否合理，是否FullGC次数多

## 程序编译和代码优化

### 早期编译优化

语法糖擦除

### 晚期优化

- JIT,即时编译

  针对热点代码通过即时编译生成机器码

- 方法内联

  减少方法的调用

- 逃逸分析

  分析出无法逃逸的对象，然后做栈上分配、同步消除、标量替换


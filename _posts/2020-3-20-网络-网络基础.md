---
layout: post
title: "网络基础"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 网络
    - 笔记
---

# 网络基础

##TCP UDP
### tcp/udp定义
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
### tcp三次握手和四次挥手
tcp是全双工通信 
握手过程：
A:我说话你能听到吗
B:能听到，我说话你能听到吗
A:可以听到
挥手过程：
A:喂，我不说了
B:我知道了，上一句还没说完
B:上一句说完了，我也不说了
A:知道了

## 长连接、短连接、长轮询、短轮询、websocket、心跳

 > 参考 https://www.cnblogs.com/stateis0/p/9255966.html

- 长短连接主要取决服务端和客户端是否主动去关闭了连接；
- 长轮询是在客户端轮询，服务端事件监听，spring 的DeferredResult;实质是通过循环建立长连接，既能降低tcp连接新建的开销又能减轻服务端维持tcp连接的开销
- websocket全双工通讯协议；长连接+全双工通讯
  - 单工：只有一方能发消息
  - 半双工：双方都能发消息，同一个时间点只有一方能发，类似对讲机
  - 全双工：双方同时能发消息，类似电话
- 长连接缺点：对网络环境要求高，容易推送失败。且有双写问题。
- 心跳：客户端发送存活心跳包，以维持和服务端连接。



## BIO->NIO->多路复用NIO

**BIO（同步阻塞IO）造成线程阻塞**

> 调用read函数等待socket有数据过来；每个客户端请求过来就要占用一个线程

  问题：

- 必须多线程
- 大量的线程切花浪费cpu
- 线程数多占用内存大

**NIO(同步非阻塞IO)**

> 调用read函数，如果Socket没有数据立即返回不阻塞，然后间隔一段时间，再次调用read( while循环 )

优点：相对BIO不阻塞程序

问题：

- 如果有大量文件描述符都要等，那么就得一个一个的read。这会带来大量的Context Switch（`read`是系统调用，每调用一次就得在用户态和核心态切换一次）
- 休息一会的时间不好把握。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已

**多路复用NIO(同步非阻塞IO) 之select模型，不会线程阻塞，但是会让内核循环次数多；多路复用**

> 过程：假如有一千个客户端连接，redis server通过select把一千个连接的文件描述符给到内核，内核循环一千个描述符;select期间程序是block的；

优点：相对NIO,减少了Read的次数，减少了用户态到内核态的切换

问题：

- `select`能够支持的最大的fd数组的长度是1024。这对要处理高并发的web服务器是不可接受的。
- `select`返回后要挨个遍历fd，找到被“SET”的那些进行处理。这样比较低效。
-  select是无状态的，即每次调用`select`，内核都要重新检查所有被注册的fd的状态



**多路复用NIO(同步非阻塞)  之epoll模型，**

> 使用epoll_create在内存创建一个数据表，通过epoll_ctl管理要监听的文件描述符；最终通过事件机制，有数据写入后内核把有数据的文件描述符放到一个指定位置，redis server的epoll_wait循环读取这个空间

优点：

- 相对于select,每次都需要把完整的fd列表传入到内核，迫使内核每次必须从头扫描到尾,epoll通过epoll_ctl有客户端连接时才注册一个fd到内核中
- 相对于select的需要全量变量select函数返回的fd检查有没有数据；epoll通过epoll_wait仅返回有数据的fd

**AIO(异步非阻塞)**

由于AIO比NIO没有明显的性能优势，代码实现比NIO复杂，发展不太理想，Redis和Netty都没有用

**阻塞与非阻塞**

> 阻塞：没有数据传过来时，读会阻塞直到有数据；缓存区满时，写操作也会阻塞
>
> 非阻塞：非阻塞在上述情况是都是直接返回

**同步和异步**

> 同步：数据就绪了需要自己去读时同步
>
> 异步：数据就绪后直接读好再回调给程序是异步
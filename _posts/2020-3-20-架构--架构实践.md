---
layout: post
title: "架构实践"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 架构
---

# 架构实践
## 基础

### 思维

架构设计的关键思维是判断和取舍，程序设计的关键是逻辑和实现

### 架构是什么

软件架构指软件系统的顶层结构

### 架构的目的

架构设计的主要目的是为了解决软件系统复杂度带来的问题

### 复杂度来源

- 高性能
- 高可用
- 可扩展
- 低成本、安全、规模

### 架构设计原则

- 合适原则：合适优先于业界领先
- 简单原则： 简单优于复杂
- 演化原则：演化优于一步到位

## 高性能架构

### 高性能数据库集群：读写分离

### 高性能数据库集群：分库分表

### 高性能NoSQL

### 高性能缓存架构

### 负载均衡

## 高可用架构

cap理论指导

### 高可用存储架构：双机架构

### 高可用存储架构：集群和分区

### 业务高可用保证：异地多活

- 同城异区

  同城架设高速电缆通道；数据一致性最高

- 跨城异地

  新闻类

- 跨国异地

  主要用来满足为不同地区用户提供服务和只读类服务

**异地多活设计的理念可以总结为一句话：采用多种手段，保证绝大部分用户的核心业务异地多活**

实现异地多活的四个技巧：

- 技巧 1：保证核心业务的异地多活

  优先实现核心业务的异地多活架构！对于这个用户系统来说，“登录”才是最核心的业务，“注册”和“用户信息”虽然也是主要业务，但并不一定要实现异地多活，主要原因在于业务影响不同。对于一个日活 1000 万的业务来说，每天注册用户可能是几万，修改用户信息的可能还不到 1 万，但登录用户是 1000 万，很明显我们应该保证登录的异地多活。

  而登录实现“异地多活”恰恰是最简单的，因为每个中心都有所有用户的账号和密码信息，用户在哪个中心都可以登录。用户在 A 中心登录，A 中心宕机后，用户到 B 中心重新登录即可

- 技巧 2：保证核心数据最终一致性

  以前面的“用户子系统”为例，用户登录所产生的 token 或者 session 信息，数据量很大，但其实并不需要同步到其他业务中心，因为这些数据丢失后重新登录就可以再次获取了。

- 技巧 3：采用多种手段同步数据

  - 消息队列方式
  - 二次读取方式
  - 存储系统同步方式

- 技巧 4：只保证绝大部分用户的异地多活

  某些场景下我们无法保证 100% 的业务可用性，总是会有一定的损失。例如，密码不同步导致无法登录、用户信息不同步导致用户看到旧的信息等，这个问题怎么解决呢？

  很遗憾，答案是没有！异地多活也无法保证 100% 的业务可用

  虽然无法做到“实时转账”的异地多活，但可以通过特殊的业务手段让转账业务也能实现异地多活；例如，转账业务除了“实时转账”外，还提供“转账申请”业务，即小明在上海业务中心提交转账请求，但上海的业务中心并不立即转账，而是记录这个转账请求，然后后台异步发起真正的转账操作，如果此时北京业务中心不可用，转账请求就可以继续等待重试；假设等待 2 个小时后北京业务中心恢复了，此时上海业务中心去请求转账，发现余额不够，这个转账请求就失败了。小明再登录上来就会看到转账申请失败，原因是“余额不足”。

  虽然我们无法做到 100% 可用性，但并不意味着我们什么都不能做，为了让用户心里更好受一些，我们可以采取一些措施进行安抚或者补偿，例如：

-  挂公告

  说明现在有问题和基本的问题原因，如果不明确原因或者不方便说出原因，可以发布“技术哥哥正在紧急处理”这类比较轻松和有趣的公告。
  
- 事后对用户进行补偿
  

例如，送一些业务上可用的代金券、小礼包等，减少用户的抱怨。

- 补充体验
  
  对于为了做异地多活而带来的体验损失，可以想一些方法减少或者规避。以“转账申请”为例，为了让用户不用确认转账申请是否成功，我们可以在转账成功或者失败后直接给用户发个短信，告诉他转账结果，这样用户就不用时不时地登录系统来确认转账是否成功了
  
  
  





---
layout: post
title: "Java并发编程"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - Java 
    - 笔记
---

# 多线程

## 锁

### 什么时候考虑锁

> 用锁是因为要访问临界资源

- 单例模式时，改变单例类的全局变量时，一定要考虑锁的问题

### synconized

#### 对象内存对象布局 

> https://www.jianshu.com/p/91e398d5d17c

12字节的头  markword

moniterenter

moniterexit 

lock cmpxcge

Cas 自旋

#### 锁升级

> https://blog.csdn.net/tongdanping/article/details/79647337

偏向锁(对象头记录线程id)-->轻量级锁(cas)-->重量级锁（线程阻塞）



### ReentrantLock

适用场景：时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票

### volatile

> 内存屏障实现 MESI

####线程可见

应用实例：唯一ID解决时间回拨

#### 禁止指令重排

应用实例：DCL

对象初始化过程：（半初始化）

```java
class T {
  long m=8;
}
T t1=new T();
```

- 初始化一个T,m=0
- 调用T的构造函数，m此时更新成8
- t1和T实例关联

如果在DCL中实例变量未加volite,在极端情况下发生了指令重排，上面的第三步和第二步发生了互换排序，有个线程拿到的t1是m=0的；

### 锁的优化

#### 锁粗化

按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 
但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。 
锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

#### 锁消除

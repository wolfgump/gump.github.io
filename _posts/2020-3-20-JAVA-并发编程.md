---
layout: post
title: "Java并发编程"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - Java 
    - 笔记
---

# 并发编程

## 锁

### 什么时候考虑锁

> 用锁是因为要访问临界资源

- 单例模式时，改变单例类的全局变量时，一定要考虑锁的问题

## synconized

### 对象内存对象布局 

> https://www.jianshu.com/p/91e398d5d17c
>
> 12字节的头  markword

moniterenter

moniterexit 

lock cmpxcge、Cas 自旋

### 锁升级

> https://blog.csdn.net/tongdanping/article/details/79647337

偏向锁(对象头记录线程id)-->轻量级锁(cas)-->重量级锁（线程阻塞）



## ReentrantLock

适用场景：时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票

依赖AQS实现锁功能

## volatile

> 内存屏障实现 MESI

###线程可见

应用实例：唯一ID解决时间回拨

### 禁止指令重排

应用实例：DCL

### 对象初始化过程：（半初始化）

```java
class T {
  long m=8;
}
T t1=new T();
```

- 初始化一个T,m=0
- 调用T的构造函数，m此时更新成8
- t1和T实例关联

如果在DCL中实例变量未加volite,在极端情况下发生了指令重排，上面的第三步和第二步发生了互换排序，有个线程拿到的t1是m=0的；

## 锁的优化

### 锁粗化

按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 
但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。 
锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。

### 锁消除

### Semaphore 信号令和 漏桶令牌区别

- semaphore主要用来限制并发数防止资源耗尽；如用来限制请求的并发数、数据库连接数
- 漏桶和令牌是用来限制QPS的；它们都一个特点是以一定的速率

### CountDownLatch 和 CyclicBarrier

主要区别：

- One major difference is that [CyclicBarrier](http://download.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/CyclicBarrier.html) takes an (optional) Runnable task which is run once the common barrier condition is met.

  > For simple use cases - services starting etc... a CountdownLatch is fine. A CyclicBarrier is useful for more complex co-ordination tasks. An example of such a thing would be parallel computation - where multiple subtasks are involved in the computation - kind of like [MapReduce](http://en.wikipedia.org/wiki/MapReduce).

- When using a `CyclicBarrier`, the assumption is that you specify the number of waiting threads that trigger the barrier. If you specify 5, you must have at least 5 threads to call `await()`;When using a `CountDownLatch`, you specify the number of calls to `countDown()` that will result in all waiting threads being released. This means that you can use a `CountDownLatch` with only a single thread.s

### Object的await、notfiy和Condition的区别

- Condition having multiple wait-sets per object，对于同一个锁对象，Condition可以有多个等待条件

  ```java
  //synchronized + Object
  synchronized(obj){
  obj.wait();
  A do something
  }
  //ReentrantLock + Condition
   class BoundedBuffer {
      <b>final Lock lock = new ReentrantLock();</b>
      final Condition notFull  = <b>lock.newCondition(); </b>
      final Condition notEmpty = <b>lock.newCondition(); </b>
  
  ```

- Condition多了两个方法awaitUninterruptibly和awaitUntil，有些场景会比较有用


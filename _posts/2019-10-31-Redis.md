---
layout: post
title:  "Redis"
date:   2019-10-31 20:00:21 +0800
categories:  架构
--- 

## 高性能原因

纯内存操作
单线程 避免线程切换开销
NIO多路复用

## 持久化

RDB fork一个线程做持久化 非实时
AOF 
## Redis hash怎么实现的 rehash过程

redis hash数据字节里有两个hashtable 
rehash过程：
1.为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
2.在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
3.在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
4.随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

## DML(Distributed Lock Manager)

### 普通实现（基于主从哨兵模式）

redis里写入一个可以，设置一个过期时间

缺点：存在单点故障，主节点挂掉，数据还未同步到从节点时，另外一个客户端可以再次获得锁

### 正确的实现方式（基于主从哨兵模式）

```shell
  SET resource_name my_random_value NX PX 30000
```



```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

保证客户端解锁的一定是自己加的锁

``` 什么场景下可能会出现解锁的不是自己加的锁？1.加锁后本地处理时间长，锁过期时间到了。 2.主节点挂掉，部分数据为未及时同步到从节点```

my_random_value可以使用时间戳加客户端id生成

实现：https://github.com/redisson/redisson  （实例了 公平/非公平 重入锁、解锁通知其他等待线程  还是先了RedLock）

### RedLock(基于多个独立redis的分布式锁实现 )

使用场景：有N个redis 的matser，各自独立，没有任何关系(不在一个cluster下)，可以部署在不同的服务器或是虚拟机上

### Redis部署架构

#### 主从

缺点：master挂了以后不能对外提供些服务了

#### 主从+哨兵

主从的基础上加上哨兵节点，当主挂了以后，哨兵节点在从中选出一个主

缺点：当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了

#### 集群

cluster的出现是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器

## 常用数据结构及命令

- Hash  内部存储的Value为一个HashMap

  使用场景：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，




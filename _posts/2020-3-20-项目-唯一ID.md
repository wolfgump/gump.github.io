---
layout: post
title: "唯一ID服务"
subtitle: ''
comments: true
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 项目 
    - 笔记
---





# 唯一ID
## 业务场景

- 分库分表后，需要跨表跨库的自增主键
- 要满足产品各种自定义格式的单据号
- ToC场景订单号

## 业务特点：

- 分库分表后，需要跨表跨库的自增主键
  - 数字
  - 连续递增
  - 不重复
- 要满足产品各种自定义格式的单据号
  - 支持格式自定义
  - 周期性可重复
  - 周期内递增
- ToC场景订单号
  - 要有递增趋势但不连续
  - 高性能、高可用
  - 不重复

## 现有解决方案

### Mysql 主键

优点：实现简单，利用现有数据库系统的功能实现

缺点：

- 强依赖DB
- Mysql单机性能限制

## Mysql+Redis

一次性生成一批序号放到Redis中。Mysql中记录一个生成序号的个数，当前序号的最大值

优点：降低mysql的压力，性能比较mysql主键方式好

缺点：

- 依赖redis锁，出现性能瓶颈时很难快速水平扩展
- 强依赖Redis和Mysql

### UUID

优点：性能非常高：本地生成，没有网络消耗。

缺点：

- 不适合做主键，主键建议：数字、越短越好、有序

- UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。

- 不安全，于MAC地址生成UUID的算法可能会造成MAC地址泄露

  

### SnowFlake

![snowflake](/img/project/snowflake.png)


优点：

- 不依赖其它中间件
- 容易横向扩展

缺点：

- 集群规模大时手动维护workID困难
- 发生时钟回拨会生成重复的ID

### 美团Leaf

https://github.com/Meituan-Dianping/Leaf

### sharding-jdbc、nacos（有重复的可能性）

http://www.cluozy.com/home/hexo/2018/08/11/shariding-JDBC-snowflake/

### mongo db (有重复的可能性)

https://docs.mongodb.com/manual/reference/method/ObjectId/



## 唯一编码服务（类Mysql+Redis方案）

### 使用说明

- 申请成为接入方，得到一个tenantId

- 定义模板  GZD(yyyMMdd)[8]
  - GZD  自定义字符串，可以放到任意位置，如GZD(yyyMMdd)[8],(yyyMMdd)GZD[8],(yyyMMdd)[8]GZD
  - (yyyyMMdd) 小括号内部，小括号内日期格式参见https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html
  - [8] 连续递增序列，数字表示递增序列的的长度，最大18位
- 调用接口生成编码 /api/sequence/next

### 使用场景

- 分库分表后的的自增主键、分布式事物ID,分布式消息ID;直接定义模板[18]
- 自定义格式的业务单据；

### 实现细节

- 解析模板，假设模板是：BDSQ(yyyyMMdd)[5]，解析后的模板,BDSQ{0,date,yyyyMMdd}{1}；

- 根据模板生成序列放入Redis

    ```java
     long maxId = (long) (Math.pow(10.0D, (double) resolvedTemplateEntity.getSequenceLength()) - 1.0D);
            if (bizSequence == null) {
                bizSequence = new BizSequenceDO();
                bizSequence.setCurrentValue(1L);
                int step = (int) Math.min(maxId / 20L, 5000L);
                if (step <= 0) {
                    step =` 1;
                }
                bizSequence.setStep(step);
                bizSequence.setMaxId(maxId);
                bizSequence.setBizCode(sequenceTemplate.getBizCode());
                bizSequence.setTenantId(sequenceTemplate.getTenantId());
                bizSequence.setRefreshStrategy(resolvedTemplateEntity.getRefreshStrategy().name());
                bizSequence.setNextResetTime(nextResetTime == null ? null : new Timestamp(nextResetTime.getTime()));
                bizSequenceMapper.insert(bizSequence);
            }
    ```

    

- 在Redis 中获取序列

  ```java
  					try {
                  if (!RedisLock.tryAcquireLock(redisTemplate, writeLockKey, requestId, timeOut, expireTime, TimeUnit.MILLISECONDS)) {
                      throw new BusinessException("501", String.format("get redis lock error,lockKey=%s", writeLockKey));
                  }
                  sequence = redisTemplate.opsForList().rightPop(sequenceKey);
                  if (null == sequence) {
                      this.fresh(resolvedTemplateEntity);
                      sequence = redisTemplate.opsForList().rightPop(sequenceKey);
                  }
              } catch (Exception ex) {
                  throw new BusinessException("501", ex.toString());
              } finally {
                  if (!RedisLock.releaseDistributedLock(redisTemplate, writeLockKey, requestId)) {
                      log.error("fail to release lock, lockKey={}", writeLockKey);
                  }
  
              }
  ```

- Redis里加锁, 自旋轻量级锁

  ```java
   public static boolean tryAcquireLock(RedisTemplate redisTemplate, String lockKey, String requestId, long timeout, int expireTime, TimeUnit unit) {
          long deadLine = System.nanoTime() + unit.toNanos(timeout);
          redisTemplate.setValueSerializer(new StringRedisSerializer());
          do {
              Boolean result = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, expireTime, unit);
              if (result) {
                  return true;
              }
              try {
                  Thread.sleep(10L);
              } catch (InterruptedException var11) {
                  log.error("RedisLock#tryAcquireLock", var11);
                  // Restore interrupted state...
                  Thread.currentThread().interrupt();
              }
          } while (System.nanoTime() < deadLine);
  
          return false;
      }
  ```

- Redis 里解锁,LUA脚本保证事物性

    ````java
     /**
         * 保证释放的锁一定是同一个requestId加的锁 使用LUA脚本
         * @param redisTemplate
         * @param lockKey
         * @param requestId
         * @return
         */
        public static boolean releaseDistributedLock(RedisTemplate redisTemplate, String lockKey, String requestId) {
            redisTemplate.setValueSerializer(new StringRedisSerializer());
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
            DefaultRedisScript defaultRedisScript = new DefaultRedisScript();
            defaultRedisScript.setScriptText(script);
            defaultRedisScript.setResultType(Long.class);
            Long result = (Long) redisTemplate.execute(defaultRedisScript, Collections.singletonList(lockKey), requestId);
            return RELEASE_SUCCESS.equals(result);
        }
    ````

    ### 缺点：
    
    - 依赖redis锁，出现性能瓶颈时很难快速水平扩展
    - 强依赖Redis和Mysql
    
    ### 改进
    
    - Mysql服务器主备
    - 号段快用尽时提前从数据库取号
    - 客户端缓存小范围号段
    - Redis集群
    
    

## 唯一ID服务（类 SnowFlake方案）

### 使用说明

- 申请成为接入方，得到一个tenantId

- 直接调用接口生成,/api/id/next

### 实现细节

- 解决大规模机器下维护机器ID困难问题

  - 通过Ip+端口号在程序启动的时候获取一次机器ID;只在程序启动时依赖reids,生产ID时不依赖Redis

    ```java
    public Long getWorkerId(String ip, Integer port) {
            ListOperations<String, String> listOperations = redisTemplate.opsForList();
            List<String> workIdKeyList = listOperations.range(RedisKeyConstant.WORK_ID_KEY, 0, -1);
            Long workId = 0L;
            String workerIdKey = String.format("%s_%s", ip, port);
            if (CollectionUtils.isNotEmpty(workIdKeyList) && workIdKeyList.contains(workerIdKey)) {
                int index = workIdKeyList.indexOf(workerIdKey);
                workId = Long.valueOf(index) + 1;
            } else {
                Long length = listOperations.rightPush(RedisKeyConstant.WORK_ID_KEY, workerIdKey);
                workId = length;
            }
            log.info("snowflake workId:{}", workId);
            return workId;
        }
    ```

- 解决时钟回拨

  ```java
  synchronized (locks.computeIfAbsent(key, k -> new Object())) {
              long timestamp = timeGen();
              //发生了回拨，此刻时间小于上次发号时间
              if (timestamp < lastTimestamp) {
                  long offset = lastTimestamp - timestamp;
                  if (offset <= 5) {
                      try {
                          //时间偏差大小小于5ms，则等待两倍时间
                          wait(offset << 1);
                          timestamp = timeGen();
                          if (timestamp < lastTimestamp) {
                              throw new BusinessException("500", "current time less than lastGenIdTime");
                          }
                      } catch (InterruptedException e) {
                          log.error("wait interrupted");
                          throw new BusinessException("500", e);
                      }
                  } else {
                      throw new BusinessException("500", "current time less than lastGenIdTime");
                  }
              }
  ```
  
-  10 位序列号生成
  
  ```java
   //如果是同一时间生成的，则进行毫秒内序列
              if (lastTimestamp == timestamp) {
                  sequence = (sequence + 1) & sequenceMask;
                  if (sequence == 0) {
                      //sequence 为0的时候表示是下一毫秒时间开始对seq做随机
                      sequence = RANDOM.nextInt(100);
                      //等待到下一秒
                      timestamp = tilNextMillis(lastTimestamp);
                  }
              } else {
                  //如果是新的ms开始
                  sequence = RANDOM.nextInt(100);
              }
  ```
  
-  最终序列生成
  
  ```java
  // sequenceBits=10
  // workerIdShift = sequenceBits;
  // timestampLeftShift=sequenceBits + workerIdBits;
  long id = ((timestamp - initTime) << timestampLeftShift) | (workerId << workerIdShift) | sequence;
  ```
  
  
  
  ## 总结
  
  唯一编码服务：
  
  - 格式长度自定义
  - 号段连续
  - 依赖Redis全局锁
  
  唯一ID服务
  
  - 长度固定、整体趋势递增
  - 非常容易水平扩展，高性能
  
  
  
  推荐：满足业务需求的前提下，优先使用唯一ID服务
  
  
  
  
  





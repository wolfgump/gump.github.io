---
layout: post
title: "Netty"
subtitle: ''
comments: false
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 开源项目 
    - 中间件
    - 笔记
---

# Netty

## Why netty?

如果没有netty，我们怎么办

- 很久之前  java.net + java.io
- 现代  java.nio
- 其它类似框架 mina，Grizzly

## 为什么用Netty不用NIO

- 做的更多
  - 支持常用应用层协议
  - 解决传输问题：粘包、半包
  - 支持流量整形
  - 完善的断连，Idl等异常处理
  - API更友好
  - 功能增强，如FastThreadLocal
- 做的更好
  - 规避了JDK NIO的bug;如epoll bug、IP_TOS参数使用时抛异常

## 为什么不适用其他类似框架

- Mina 和netty同作者，Mina归属Apache,作者建议使用Netty;
- Grizzly,sun公司，更新少
- Tomcat Jetty, 通讯层没有单独拆分出来；（Tomcat Jetty 为什么底层不用Netty呢？Tomcat更先出来，那时候还没有Netty）

## Netty 关键词

NIO、 Asynchronous、event-driven

## 使用场景

- 构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务；
- 公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；
- 各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。

## 版本

最小版本4.1，废弃了5.0（用了新版本JDK更多新特性ForkJoinPool，代码复杂但性能比4.1没有明细提升）

## 三种IO模式

- BIO已过时

- NIO 同步非阻塞 推荐使用

  > 对于同一个channel，从read decode encode write都是同一个work线程处理，避免了锁的竞争；所以是同步
  >
  > 使用epoll事件模型，所以的非阻塞

- AIO 异步非阻塞 废弃（代码复杂，性能没有比NIO有明显提升）

## Reactor

**定义**

> 是一种开发模式；模式的核心流程是：注册感兴趣的时间-->扫描是否有感兴趣的事件发生-->事件发生后做相应的处理

## ByteBuf

> 网络数据过来之后可能应用处理不及时需要一个缓存区；这个缓存区是一个byte[],为了方便和高效的使用byte[],netty提供了ByteBuf类；

- 池化ByteBuf 
- 堆内存ByteBuf
- 堆外内存的ByteBuf

由于池化ByteBuf和堆外内存ByteBuf的使用，所以ByteBuf需要自己控制内存的释放，通过ReferenceCount控制引用加减，谁使用谁+1，使用完毕-1；

**每次读取多大长度的ByteBuf里的byte去转换成应用层对象呢？**  -- 此时需要编解码



## 编解码

**为什么需要编解码**

主要以下原因：

- 粘包

  为了发送的的效率，小包会组合在一次发送

- 分包

  传输链路能传最大的包的限制，过大的包需要拆分成多个包发送
  
- 数据处理不及时 

粘包、分包在每一层都会存在，每层需要自己处理；IP层处理完自己的粘包问题后交给TCP层，TCP处理完粘包问题后交给应用层；

IP和TCP是标准的协议层，由操作系统支持，在操作系统层面完成拆包和组包；是用netty是不需要关系，IP和TCP都是通过header标注长度的方式解决粘包问题

使用Netty的时候只需要关心应用层的的粘包问题；如果应用层使用标准的http协议，配置上http的解码器就行；如果是自己定义协议，就需要自己去制定解码器；可以基于Netty提供的固定长度、分割符、文件头的基础解码器上扩展

**为什么ip层、tcp层处理了粘包了，应用层还需要处理？**

> 举个列子：客户端发送了A、B、C; TCP可能一个包就传输过去了，也可能多个包传输过去；这个缓存区可能是A、AB、ABC; 服务端面对缓存区了的ABC怎么知道要读成A、B、C这三个字母而不是ABC这个短语呢？所以这个时候就需要应用层的解码，最简单的读取固定长度1
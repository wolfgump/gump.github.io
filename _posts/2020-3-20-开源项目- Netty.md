---
layout: post
title: "Netty"
subtitle: ''
comments: true
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 开源项目 
    - 中间件
    - 笔记
---

# Netty

## Why netty?

如果没有netty，我们怎么办

- 很久之前  java.net + java.io
- 现代  java.nio
- 其它类似框架 mina，Grizzly

## 为什么用Netty不用NIO

- 做的更多
  - 支持常用应用层协议
  - 解决传输问题：粘包、半包
  - 支持流量整形
  - 完善的断连，Idl等异常处理
  - API更友好
  - 功能增强，如FastThreadLocal
- 做的更好
  - 规避了JDK NIO的bug;如epoll bug、IP_TOS参数使用时抛异常

## 为什么不适用其他类似框架

- Mina 和netty同作者，Mina归属Apache,作者建议使用Netty;
- Grizzly,sun公司，更新少
- Tomcat Jetty, 通讯层没有单独拆分出来；（Tomcat Jetty 为什么底层不用Netty呢？Tomcat更先出来，那时候还没有Netty）

## Netty 关键词

NIO、 Asynchronous、event-driven

## 使用场景

- 构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务；
- 公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；
- 各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。

## 版本

最小版本4.1，废弃了5.0（用了新版本JDK更多新特性ForkJoinPool，代码复杂但性能比4.1没有明细提升）

## 三种IO模式

- BIO已过时

<<<<<<< HEAD
   EventLoopGroup bossGroup = new BioEventLoopGroup();

- NIO 推荐使用

   EventLoopGroup bossGroup = new NioEventLoopGroup();

- AIO 废弃（代码复杂，性能没有比NIO有明显提升）
=======
- NIO 同步非阻塞 推荐使用

  > 对于同一个channel，从read decode encode write都是同一个work线程处理，避免了锁的竞争；所以是同步
  >
  > 使用epoll事件模型，所以的非阻塞

- AIO 异步非阻塞 废弃（代码复杂，性能没有比NIO有明显提升）
>>>>>>> 82ff1c1f8d72fbb295b0f88bc64c06a63a414478

   EventLoopGroup bossGroup = new AioEventLoopGroup();

## Reactor

**定义**

> 是一种开发模式；模式的核心流程是：注册感兴趣的时间-->扫描是否有感兴趣的事件发生-->事件发生后做相应的处理

分类

- 单线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup(1);
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup)
  ```

  

- 多线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup();
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup)
  ```

  

- 主（Boss）从(Worker)多线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup();
   EventLoopGroup workerGroup = new NioEventLoopGroup();
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup,workerGroup)
  ```

EventLoopGroup的核心是SelectorProvider，不同平台JDK提供不同的SelectorProvider

## 粘包、半包

定义

- 粘包，不同的发送请求放到了一个网络包中传输
- 半包，一次发送请求被拆分到不同的网络包中传输

根本原因：TCP是流式协议，消息没有边界；UDP协议不会有粘包、半包问题，UDP消息是有边界的

解决办法

![zhanbao](/img/netty/zhanbao.jpg)



## 二次编解码

定义：

> 解决粘包半包问题的解码器叫一次解码器，一次解码器的结果是字节数组，字节数组转换成项目中需要使用的对象，这层转换叫着二次解码器
>
> **一次解码器:ByteToMessageDecoder**
>
> io.netty.buffer.ByteBuf(原始数据流)---->io.netty.buffer.ByteBuf(用户数据流)
>
> **二次解码器：MessgeToMessageDecoder**
>
> io.netty.buffer.ByteBuf(用户数据流)---->Java Object

一次解码器和二次解码器能不能合并？

- 分层、结构清晰
- 耦合性低，容易替换

类型：

- Java序列化；缺点：占用空间多，不能跨语言
- XML; 优点：易读性好 缺点：占空间
- JSON; 优点：易读性好，占用空间相对少
- MessagePack 优点：多语言支持 ，占空间少  缺点：易读性差
- Hessian 
- Protobuf  优点：多语言支持，占空间少  缺点：易读性差
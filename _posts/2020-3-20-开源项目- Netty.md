---
layout: post
title: "Netty"
subtitle: ''
comments: true
author: "Gump"
header-style: text
date: 2020-3-20 20:30:21 +0800
tags:
    - 开源项目 
    - 中间件
    - 笔记
---

# Netty

## Why netty?

如果没有netty，我们怎么办

- 很久之前  java.net + java.io
- 现代  java.nio
- 其它类似框架 mina，Grizzly

## 为什么用Netty不用NIO

- 做的更多
  - 支持常用应用层协议
  - 解决传输问题：粘包、半包
  - 支持流量整形
  - 完善的断连，Idl等异常处理
  - API更友好
  - 功能增强，如FastThreadLocal
- 做的更好
  - 规避了JDK NIO的bug;如epoll bug、IP_TOS参数使用时抛异常

## 为什么不适用其他类似框架

- Mina 和netty同作者，Mina归属Apache,作者建议使用Netty;
- Grizzly,sun公司，更新少
- Tomcat Jetty, 通讯层没有单独拆分出来；（Tomcat Jetty 为什么底层不用Netty呢？Tomcat更先出来，那时候还没有Netty）

## Netty 关键词

NIO、 Asynchronous、event-driven

## 使用场景

- 构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务；
- 公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；
- 各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。

## 版本

最小版本4.1，废弃了5.0（用了新版本JDK更多新特性ForkJoinPool，代码复杂但性能比4.1没有明细提升）

## 三种IO模式

- BIO已过时
     EventLoopGroup bossGroup = new BioEventLoopGroup();

- NIO 推荐使用

   > 对于同一个channel，从read decode encode write都是同一个work线程处理，避免了锁的竞争；所以是同步
   >
   > 使用epoll事件模型，所以的非阻塞

   EventLoopGroup bossGroup = new NioEventLoopGroup();

   

- AIO 废弃（代码复杂，性能没有比NIO有明显提升）
 EventLoopGroup bossGroup = new AioEventLoopGroup();


## Reactor

**定义**

> 是一种开发模式；模式的核心流程是：注册感兴趣的时间-->扫描是否有感兴趣的事件发生-->事件发生后做相应的处理
> 分类

- 单线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup(1);
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup)
  ```

  

- 多线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup();
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup)
  ```

  

- 主（Boss）从(Worker)多线程Reactor

  ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup();
   EventLoopGroup workerGroup = new NioEventLoopGroup();
   ServerBootstrap b = new ServerBootstrap();
   b.group(bossGroup,workerGroup)
  ```

EventLoopGroup的核心是SelectorProvider，不同平台JDK提供不同的SelectorProvider

## 粘包、半包

定义

- 粘包，不同的发送请求放到了一个网络包中传输
- 半包，一次发送请求被拆分到不同的网络包中传输

根本原因：TCP是流式协议，消息没有边界；UDP协议不会有粘包、半包问题，UDP消息是有边界的

解决办法

![zhanbao](/img/netty/zhanbao.jpg)



## 二次编解码

定义：

> 解决粘包半包问题的解码器叫一次解码器，一次解码器的结果是字节数组，字节数组转换成项目中需要使用的对象，这层转换叫着二次解码器
>
> **一次解码器:ByteToMessageDecoder**
>
> io.netty.buffer.ByteBuf(原始数据流)---->io.netty.buffer.ByteBuf(用户数据流)
>
> **二次解码器：MessgeToMessageDecoder**
>
> io.netty.buffer.ByteBuf(用户数据流)---->Java Object

一次解码器和二次解码器能不能合并？

- 分层、结构清晰
- 耦合性低，容易替换

类型：

- Java序列化；缺点：占用空间多，不能跨语言
- XML; 优点：易读性好 缺点：占空间
- JSON; 优点：易读性好，占用空间相对少
- MessagePack 优点：多语言支持 ，占空间少  缺点：易读性差
- Hessian 
- Protobuf  优点：多语言支持，占空间少  缺点：易读性差

## ByteBuf

> 网络数据过来之后可能应用处理不及时需要一个缓存区；这个缓存区是一个byte[],为了方便和高效的使用byte[],netty提供了ByteBuf类；

- 池化ByteBuf 
- 堆内存ByteBuf
- 堆外内存的ByteBuf

由于池化ByteBuf和堆外内存ByteBuf的使用，所以ByteBuf需要自己控制内存的释放，通过ReferenceCount控制引用加减，谁使用谁+1，使用完毕-1；

**每次读取多大长度的ByteBuf里的byte去转换成应用层对象呢？**  -- 此时需要编解码



## 编解码

**为什么需要编解码**

主要以下原因：

- 粘包

  为了发送的的效率，小包会组合在一次发送

- 分包

  传输链路能传最大的包的限制，过大的包需要拆分成多个包发送
  
- 数据处理不及时 

粘包、分包在每一层都会存在，每层需要自己处理；IP层处理完自己的粘包问题后交给TCP层，TCP处理完粘包问题后交给应用层；

IP和TCP是标准的协议层，由操作系统支持，在操作系统层面完成拆包和组包；是用netty是不需要关系，IP和TCP都是通过header标注长度的方式解决粘包问题

使用Netty的时候只需要关心应用层的的粘包问题；如果应用层使用标准的http协议，配置上http的解码器就行；如果是自己定义协议，就需要自己去制定解码器；可以基于Netty提供的固定长度、分割符、文件头的基础解码器上扩展

**为什么ip层、tcp层处理了粘包了，应用层还需要处理？**

> 举个列子：客户端发送了A、B、C; TCP可能一个包就传输过去了，也可能多个包传输过去；这个缓存区可能是A、AB、ABC; 服务端面对缓存区了的ABC怎么知道要读成A、B、C这三个字母而不是ABC这个短语呢？所以这个时候就需要应用层的解码，最简单的读取固定长度1

## Netty 能创建多少链接

[https://github.com/jiafu1115/netty-puzzle-100/blob/master/Puzzle-1%20Netty%E8%83%BD%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E8%BF%9E%E6%8E%A5%3F](https://github.com/jiafu1115/netty-puzzle-100/blob/master/Puzzle-1 Netty能创建多少连接%3F)

## Netty 调优

### 系统参数

- 文件句柄数  默认值 1024*1024 百万级； 如果系统RAM大，要支持超百万级连接，就需要调整这个参数

### Netty的系统参数

 原则：不懂不要动，可配置